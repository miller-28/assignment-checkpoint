# General AI Development Guide

A comprehensive guide for AI agents to understand and contribute effectively to software projects with best practices and architectural principles.

## Core Implementation Rules

### Code Quality Principles

**SOLID Principles**
- **Single Responsibility Principle (SRP)**: Each class/module should have one reason to change. Keep components focused on a single purpose.
- **Open/Closed Principle (OCP)**: Code should be open for extension but closed for modification. Use abstractions and interfaces.
- **Liskov Substitution Principle (LSP)**: Derived classes must be substitutable for their base classes without breaking functionality.
- **Interface Segregation Principle (ISP)**: Clients should not depend on interfaces they don't use. Keep interfaces focused and minimal.
- **Dependency Inversion Principle (DIP)**: Depend on abstractions, not concretions. High-level modules should not depend on low-level modules.

**DRY (Don't Repeat Yourself)**
- Eliminate code duplication through abstraction and reusable components.
- Extract common logic into shared functions, utilities, or base classes.
- Use configuration over code duplication.
- Avoid copy-paste programming; refactor repeated patterns.

**Avoid Code Smells**
- **Long Methods**: Break down into smaller, focused functions (max 20-30 lines recommended).
- **Large Classes**: Split into smaller, cohesive classes following SRP.
- **Long Parameter Lists**: Use parameter objects or builder patterns.
- **Duplicate Code**: Extract to shared utilities or base classes.
- **Dead Code**: Remove unused code, functions, and imports.
- **Magic Numbers**: Use named constants with descriptive names.
- **Nested Conditionals**: Flatten logic using early returns and guard clauses.
- **Primitive Obsession**: Use value objects and domain types instead of primitives.
- **Feature Envy**: Methods should primarily use data from their own class.
- **Data Clumps**: Group related data into cohesive objects.

### Architectural Principles

**Separation of Concerns**
- Clearly separate business logic, data access, presentation, and infrastructure.
- Each layer should have distinct responsibilities and minimal coupling.
- Use layered architecture: Presentation → Application → Domain → Infrastructure.
- Keep domain logic independent of frameworks and external dependencies.

**Modularity**
- Design systems as independent, interchangeable modules.
- Each module should have well-defined boundaries and interfaces.
- Minimize coupling between modules; maximize cohesion within modules.
- Support independent development, testing, and deployment of modules.

### Code Readability & Maintainability

**Descriptive Naming**
- Use clear, self-documenting names that reveal intent.
- **Classes**: Nouns representing domain concepts (e.g., `UserAccount`, `OrderProcessor`, `PaymentGateway`).
- **Functions/Methods**: Verbs describing actions (e.g., `calculateTotal`, `validateEmail`, `processPayment`).
- **Variables**: Descriptive nouns in snake_case (e.g., `customer_email`, `total_amount`, `is_authenticated`).
- **Constants**: UPPER_SNAKE_CASE for clarity (e.g., `MAX_RETRY_ATTEMPTS`, `DEFAULT_TIMEOUT`).
- **Booleans**: Use question prefixes (`is`, `has`, `can`, `should`) for clarity.
- Avoid abbreviations unless universally understood (e.g., `id`, `url`, `html`).

**Code Simplicity**
- Write simple, straightforward code over clever or complex solutions.
- Prefer clarity over brevity; code is read far more than written.
- Use guard clauses and early returns to reduce nesting.
- Keep cyclomatic complexity low (target < 10 per function).
- Break complex logic into smaller, named helper functions.
- Use meaningful intermediate variables to clarify complex expressions.

**Developer-Friendly Code**
- Write code that reads like well-written prose.
- Add comments only for "why" not "what" (code should be self-explanatory).
- Use consistent formatting and style throughout the codebase.
- Structure code logically with related concepts grouped together.
- Keep files focused and reasonably sized (< 300-400 lines).
- Use whitespace and line breaks to improve readability.

### Documentation Standards

**README Files**
- Use **2 spaces** for indentation (not tabs, not 4 spaces).
- Structure with clear sections: Overview, Installation, Usage, Configuration, Contributing.
- Include practical examples and common use cases.
- Keep documentation up-to-date with code changes.
- Use code blocks with language specification for syntax highlighting.

**Code Documentation**
- Document public APIs, interfaces, and complex algorithms.
- Use standard documentation formats (JSDoc, XMLDoc, docstrings, etc.).
- Include parameter descriptions, return values, and exceptions.
- Provide usage examples for non-obvious functionality.

---

## Additional Best Practices & Approaches

Below are additional software engineering practices and patterns. Review and select which ones to incorporate:

### Testing Strategy

**Test-Driven Development (TDD)**
- Apply TDD for both client and server development.
- Write tests before implementation to drive design.

**Testing Focus & Coverage**
- Prioritize **high coverage for crucial parts** of the application.
- Focus testing on **front controllers and interfaces** rather than exhaustive unit testing of all classes.
- Prefer **sanity tests for interface outcomes** over internal unit checks.
- **Server-side tests**: Assert proper outcomes using REST API (e.g., GET requests).
- **Insert/Update operations**: Verify against the database directly.
- **Test cleanup**: Always delete test side effects (data, mocks, temp files) after test execution.

### Design Patterns

**Pattern Usage Philosophy**
- Use design patterns **with caution** - avoid unnecessary complexity.
- Apply patterns only where they provide clear value and simplification.
- Prefer simple, straightforward code over complex pattern implementations.

**Recommended Patterns**
- **Singleton**: For shared resource management (use sparingly).
- **Factory**: For object creation with complex initialization.
- **Strategy**: For interchangeable algorithms and behaviors.
- **Template Method**: For defining algorithm skeletons with customizable steps.
- **Repository**: Abstract data access layer (DDD pattern).
- **Builder**: For complex object construction.
- **Adapter**: For incompatible interfaces.
- **Decorator**: For adding responsibilities dynamically.
- **Observer**: For event-driven architectures.

### Performance & Scalability

**Core Performance Practices (Mandatory)**
- **Database Indexing**: Optimize query performance.

### Security & Authentication

**Input Validation (Mandatory)**
- **Always validate on both server-side AND client-side**.
- Validate all user inputs before processing.
- Sanitize data to prevent injection attacks.
- Use schema validation libraries for structured data.
- **Output Encoding**: Prevent injection attacks.

**Authentication & Authorization Architecture**
- Implement **ACL (Access Control List) star mechanism** with:
  - **Resource**: Protected entities/endpoints
  - **Action**: Operations (read, write, delete, etc.)
  - **User**: Authenticated user identity
  - **Role**: User role assignments
  - **Permission**: Granular access rights

**Session & Token Management**
- **Server-side**: Store sessions in **Memcached** for scalability and performance.
- **Client-side**: Use **JWT (JSON Web Tokens)** to encapsulate:
  - User data
  - Permissions
  - Roles
  - Expiration information

### Error Handling & Resilience

**Core Error Handling (Mandatory)**
- **Graceful Degradation**: Maintain functionality when dependencies fail.
- **Health Checks**: Monitor service availability.
- **Centralized Error Handling**: Global error handling middleware.
- **Circuit Breaker Pattern**: Prevent cascade failures.

**Error Response Format (Mandatory)**
- Return structured error responses with support for multiple errors:
```json
{
  "errors": [
    {
      "error_code": "VALIDATION_ERROR",
      "error_description": "Email format is invalid",
      "error_severity": "error"
    },
    {
      "error_code": "REQUIRED_FIELD",
      "error_description": "Password is required",
      "error_severity": "error"
    }
  ]
}
```
- **error_code**: Machine-readable error identifier (UPPER_SNAKE_CASE)
- **error_description**: Human-readable error message
- **error_severity**: `info`, `warning`, `error`, `critical`
- Support single or multiple errors in the same response

**Logging Strategy (Mandatory)**
- Implement **structured logging** with consistent format across all services.
- **Log Levels**: Use appropriate levels for different scenarios:
  - `DEBUG`: Detailed diagnostic information for development
  - `INFO`: General informational messages (requests, responses, state changes)
  - `WARNING`: Recoverable issues that need attention
  - `ERROR`: Error conditions that affect functionality
  - `CRITICAL`: System-critical failures requiring immediate action
- **Log Format**: Include essential context in every log entry:
  - Timestamp (ISO 8601 format)
  - Log level
  - Service/module name
  - Request ID (for tracing)
  - User ID (when authenticated)
  - Message
  - Additional context (structured data)
- **Best Practices**:
  - Never log sensitive data (passwords, tokens, PII)
  - Use correlation IDs to trace requests across services
  - Log all API requests/responses (excluding sensitive data)
  - Log all errors with stack traces
  - Include performance metrics (response time, query duration)

### Environment & Configuration

**Environment Variables (Mandatory - Server Side)**
- Use **environment variables** for all configuration and secrets.
- Never hardcode configuration values in code.
- **Required Environment Variables**:
  - `NODE_ENV` / `APP_ENV`: Environment identifier (`development`, `staging`, `production`)
  - `PORT`: Application server port
  - `DATABASE_URL`: Database connection string
  - `MEMCACHED_URL`: Memcached server connection
  - `JWT_SECRET`: Secret key for JWT signing
  - `LOG_LEVEL`: Logging level (`debug`, `info`, `warning`, `error`, `critical`)
  - `API_VERSION`: Current API version
- **Environment-Specific Behavior**:
  - Development: Verbose logging, detailed errors, hot reload
  - Staging: Production-like setup with test data
  - Production: Minimal logging, generic error messages, optimizations
- **Configuration Files**:
  - Use `.env` files for local development (never commit to repository)
  - Use `.env.example` to document required variables
  - Use environment-specific configs: `config.development.js`, `config.production.js`
- **Secrets Management**:
  - Never commit secrets to version control
  - Use secret management services in production (AWS Secrets Manager, Azure Key Vault, etc.)
  - Rotate secrets regularly

### API Design

**REST API Standards (Primary)**
- Use **RESTful principles** as the primary API design approach.
- Apply proper **HTTP methods**: GET, POST, PUT, PATCH, DELETE.
- Return appropriate **HTTP status codes**: 200, 201, 400, 401, 403, 404, 500, etc.
- Design resource-oriented endpoints: `/users`, `/orders`, `/products/{id}`.
- Use plural nouns for collections: `/users` not `/user`.
- Implement consistent error response format.
- **API Versioning**: Support multiple API versions (e.g., `/api/v1/`).
- **Rate Limiting**: Protect against abuse.

### Data Management

**Database Migrations (Mandatory)**
- Use **version-controlled schema changes** via migration tools.
- Create reversible migrations (up/down) when possible.
- Test migrations in development before production.
- Keep migrations atomic and focused on single changes.
- Never modify existing migrations after deployment.

**Core Data Practices (Mandatory)**
- **Data Validation**: Validate at boundaries.
- **Soft Deletes**: Mark as deleted instead of physical deletion.
- **Data Encryption**: Encrypt sensitive data at rest.

### Code Maintainability & Legacy Approach

**No Legacy Support (Default)**
- **Assume no need to support legacy code** unless explicitly directed.
- When refactoring or changing implemented code:
  - **Change code brutally** without legacy remnants.
  - Remove old code completely - no commented-out code or compatibility layers.
  - Clean up unused imports, functions, and files.
  - Update all references in one go.
- Only preserve backward compatibility when specifically requested.
